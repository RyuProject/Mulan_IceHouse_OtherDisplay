#include "lvgl.h"
#include "order_ui.h"
#include "esp_log.h"
#include "bsp/display.h"
#include "bsp/esp-bsp.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "sys/queue.h"
#include "cJSON.h"
#include <ctype.h>
#include "dish_card_task.h"

// 菜品名称缓存结构（使用链表实现）
typedef struct dish_name_cache_s {
    char *original_name;
    char *decoded_name;
    uint32_t hash;
    struct dish_name_cache_s *next;
} dish_name_cache_t;

static dish_name_cache_t *dish_cache = NULL;

// 外部声明send_notification函数
extern int send_notification(const char *json_str);

// 外部声明字体
/* extern lv_font_t lv_font_mulan_14; */
extern lv_font_t *device_font;  // 设备信息字体（等待订单数据...）
extern lv_font_t *info_font;   // 弹窗消息字体（小程序已连接）
extern lv_font_t *dish_font;   // 菜品字体（出餐按钮等）
LV_FONT_DECLARE(lv_font_montserrat_14)

static const char *TAG = "OrderUI";
static lv_obj_t *orders_container = NULL;
static lv_obj_t *waiting_label = NULL; // 保存等待标签指针

// 订单状态枚举
typedef enum {
    ORDER_STATUS_PENDING,    // 等待中
    ORDER_STATUS_COMPLETED,  // 已完成
    ORDER_STATUS_REMOVED     // 已移除
} order_status_t;

// 订单数据结构
typedef struct order_info {
    char *order_id;          // 订单ID
    int order_num;           // 订单号
    char *dishes;            // 菜品信息
    lv_obj_t *row_widget;    // 订单行UI对象
    lv_obj_t *dish_label;   // 菜品标签指针
    order_status_t status;   // 订单状态
    STAILQ_ENTRY(order_info) entries;
} order_info_t;

// 订单队列
STAILQ_HEAD(order_list_head, order_info);
static struct order_list_head order_list = STAILQ_HEAD_INITIALIZER(order_list);

// 按钮点击事件：已出餐（优化锁定时间）
static void btn_ready_cb(lv_event_t *e)
{
    bsp_display_lock(0); // 使用0ms超时，减少阻塞
    
    lv_obj_t *btn = lv_event_get_target(e);
    lv_obj_t *label = lv_obj_get_child(btn, 0);  // 获取按钮内的 label
    if (label) {
        lv_label_set_text(label, "出餐");
    }

    // 修改按钮背景色为灰色（针对MAIN部分）
    lv_obj_set_style_bg_color(btn, lv_color_hex(0xCCCCCC), LV_PART_MAIN);

    // 禁用按钮交互
    lv_obj_add_state(btn, LV_STATE_DISABLED);
    lv_obj_clear_flag(btn, LV_OBJ_FLAG_CLICKABLE);

    // 获取订单ID (从按钮的父对象中获取)
    lv_obj_t *row = lv_obj_get_parent(btn);
    if (row) {
        order_info_t *order = NULL;
        STAILQ_FOREACH(order, &order_list, entries) {
            if (order->row_widget == row) {
                // 构建JSON通知消息
                char notify_msg[128];
                snprintf(notify_msg, sizeof(notify_msg), 
                        "{\"orderId\":\"%s\",\"status\":true}", 
                        order->order_id);
                
                // 通过蓝牙通知发送
                send_notification(notify_msg);
                
                ESP_LOGI(TAG, "已发送出餐通知: %s", notify_msg);
                break;
            }
        }
    }

    ESP_LOGI(TAG, "✅ 已出餐按钮被点击并已禁用");
    bsp_display_unlock();
}

// 初始化订单UI容器
void order_ui_init(lv_obj_t *parent)
{
    bsp_display_lock(portMAX_DELAY);
    
    orders_container = lv_obj_create(parent);
    lv_obj_set_size(orders_container, LV_PCT(100), LV_PCT(100));
    lv_obj_set_flex_flow(orders_container, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(orders_container, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
    lv_obj_set_scrollbar_mode(orders_container, LV_SCROLLBAR_MODE_AUTO);
    lv_obj_set_style_pad_all(orders_container, 10, 0);

    // 初始显示等待数据 - 显示一排的等待连接字样
    waiting_label = lv_label_create(orders_container);
    lv_obj_set_style_text_font(waiting_label, device_font, 0);
    lv_label_set_text(waiting_label, "等待订单数据...");
    lv_obj_center(waiting_label);

    bsp_display_unlock();
}



/* 弹出窗口定时器回调 */
static void popup_timer_cb(lv_timer_t *timer) {
    if (!timer) return;
    
    lv_obj_t *popup = (lv_obj_t *)lv_timer_get_user_data(timer);
    
    // 仅在需要访问LVGL对象时加锁
    if (popup && lv_obj_is_valid(popup)) {
        bsp_display_lock(portMAX_DELAY);
        if (lv_obj_is_valid(popup)) {
            lv_obj_del(popup);
        }
        bsp_display_unlock();
    }
    
    lv_timer_del(timer); // 最后删除定时器，且只删一次
}

void show_popup_message(const char *message, uint32_t duration_ms) {
    bsp_display_lock(portMAX_DELAY);
    
    // 创建弹窗
    lv_obj_t *popup = lv_obj_create(lv_scr_act());
    if (!popup) {
        bsp_display_unlock();
        ESP_LOGE(TAG, "创建弹窗失败");
        return;
    }

    // 基本样式设置
    lv_obj_set_size(popup, 280, 80);
    lv_obj_center(popup);
    lv_obj_set_style_bg_color(popup, lv_color_black(), 0);
    lv_obj_set_style_bg_opa(popup, LV_OPA_COVER, 0);
    lv_obj_set_style_border_width(popup, 0, 0);
    lv_obj_set_style_pad_all(popup, 5, 0);
    lv_obj_set_style_text_font(popup, info_font, 0);

    // 创建消息标签
    lv_obj_t *label = lv_label_create(popup);
    lv_label_set_text(label, message);
    lv_obj_set_style_text_color(label, lv_color_white(), 0);
    lv_obj_center(label);

    // 设置定时器自动关闭弹出窗口
    lv_timer_t *timer = lv_timer_create(popup_timer_cb, duration_ms, popup);
    if (!timer) {
        // 定时器创建失败时手动删除弹窗
        lv_obj_del(popup);
        bsp_display_unlock();
        ESP_LOGE(TAG, "创建弹窗定时器失败");
        return;
    }
    lv_timer_set_repeat_count(timer, 1);

    bsp_display_unlock();
}

// 根据订单ID查找订单（优化性能）
static order_info_t *find_order_by_id(const char *order_id) {
    if (!order_id) return NULL;
    
    order_info_t *order;
    STAILQ_FOREACH(order, &order_list, entries) {
        if (order->order_id && strcmp(order->order_id, order_id) == 0) {
            return order;
        }
    }
    return NULL;
}

// 简单的哈希函数用于缓存键
static uint32_t simple_hash(const char *str) {
    uint32_t hash = 5381;
    int c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c; // hash * 33 + c
    }
    return hash;
}

// 查找菜品名称缓存
static char* find_dish_cache(const char *original_name) {
    if (!original_name || !dish_cache) return NULL;
    
    uint32_t hash = simple_hash(original_name);
    dish_name_cache_t *current = dish_cache;
    
    while (current) {
        if (current->hash == hash && strcmp(current->original_name, original_name) == 0) {
            ESP_LOGI(TAG, "缓存命中: %s -> %s", original_name, current->decoded_name);
            return strdup(current->decoded_name);
        }
        current = current->next;
    }
    return NULL;
}

// 添加菜品名称到缓存
static void add_dish_cache(const char *original_name, const char *decoded_name) {
    if (!original_name || !decoded_name) return;
    
    uint32_t hash = simple_hash(original_name);
    dish_name_cache_t *current = dish_cache;
    
    // 检查是否已存在
    while (current) {
        if (current->hash == hash && strcmp(current->original_name, original_name) == 0) {
            return; // 已存在，不重复添加
        }
        current = current->next;
    }
    
    // 创建新条目
    dish_name_cache_t *entry = malloc(sizeof(dish_name_cache_t));
    if (!entry) return;
    
    entry->original_name = strdup(original_name);
    entry->decoded_name = strdup(decoded_name);
    entry->hash = hash;
    entry->next = dish_cache; // 添加到链表头部
    dish_cache = entry;
    
    ESP_LOGI(TAG, "添加到缓存: %s -> %s", original_name, decoded_name);
}

// 清理菜品名称缓存
static void cleanup_dish_cache(void) {
    dish_name_cache_t *current = dish_cache;
    dish_name_cache_t *next;
    
    while (current) {
        next = current->next;
        free(current->original_name);
        free(current->decoded_name);
        free(current);
        current = next;
    }
    dish_cache = NULL;
}

// Unicode十六进制编码解码函数（优化版）- 支持UTF-8编码并添加缓存
static char* decode_unicode_hex(const char* hex_str) {
    if (!hex_str) return NULL;
    
    // 首先检查缓存
    char *cached_result = find_dish_cache(hex_str);
    if (cached_result) {
        return cached_result;
    }
    
    size_t len = strlen(hex_str);
    if (len % 2 != 0) {
        char *result = strdup(hex_str);
        add_dish_cache(hex_str, result); // 缓存原始字符串
        return result;
    }
    
    size_t out_len = len / 2 + 1;
    char* result = malloc(out_len);
    if (!result) return NULL;
    
    for (size_t i = 0, j = 0; i < len; i += 2, j++) {
        // 检查字符是否为有效的十六进制字符
        if (!isxdigit((unsigned char)hex_str[i]) || !isxdigit((unsigned char)hex_str[i+1])) {
            free(result);
            char *fallback = strdup(hex_str);
            add_dish_cache(hex_str, fallback); // 缓存原始字符串
            return fallback;
        }
        
        char hex[3] = {hex_str[i], hex_str[i+1], '\0'};
        unsigned int value;
        if (sscanf(hex, "%x", &value) != 1) {
            free(result);
            char *fallback = strdup(hex_str);
            add_dish_cache(hex_str, fallback); // 缓存原始字符串
            return fallback;
        }
        
        // 移除255的限制，支持UTF-8编码的中文字符
        result[j] = (char)(value & 0xFF); // 直接存储字节值
    }
    result[out_len - 1] = '\0';
    
    // 添加到缓存
    add_dish_cache(hex_str, result);
    return result;
}



// 创建订单行（带订单ID）- 优化版
void create_dynamic_order_row_with_id(const char *order_id, int order_num, const char *dishes) {
    bsp_display_lock(portMAX_DELAY);
    
    // 清理等待标签
    if (waiting_label && lv_obj_is_valid(waiting_label)) {
        lv_obj_del(waiting_label);
        waiting_label = NULL;
    }

    // 创建订单行
    lv_obj_t *row = lv_obj_create(orders_container);
    if (!row) {
        bsp_display_unlock();
        ESP_LOGE(TAG, "创建订单行失败");
        return;
    }
    
    // 分配订单内存
    order_info_t *order = malloc(sizeof(order_info_t));
    if (!order) {
        lv_obj_del(row);
        bsp_display_unlock();
        ESP_LOGE(TAG, "分配订单内存失败");
        return;
    }
    
    memset(order, 0, sizeof(order_info_t));
    order->order_id = strdup(order_id);
    order->dishes = strdup(dishes);
    order->order_num = order_num;
    order->row_widget = row;
    order->status = ORDER_STATUS_PENDING;
    
    if (!order->order_id || !order->dishes) {
        if (order->order_id) free(order->order_id);
        if (order->dishes) free(order->dishes);
        free(order);
        lv_obj_del(row);
        bsp_display_unlock();
        ESP_LOGE(TAG, "复制订单信息失败");
        return;
    }

    // 设置订单行样式（性能优化版）
    lv_obj_set_size(row, LV_PCT(100), 130);
    lv_obj_set_flex_flow(row, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(row, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_SPACE_BETWEEN);
    lv_obj_set_style_pad_all(row, 12, 0);
    lv_obj_set_style_radius(row, 4, 0);
    lv_obj_set_style_bg_color(row, lv_color_hex(0xFFFFFF), 0);
    lv_obj_set_style_border_width(row, 1, 0);
    lv_obj_set_style_border_color(row, lv_color_hex(0xDDDDDD), 0);
    lv_obj_clear_flag(row, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_move_to_index(row, 0);

    // 左侧：菜品容器
    lv_obj_t *left_container = lv_obj_create(row);
    if (!left_container) {
        free(order->dishes);
        free(order->order_id);
        free(order);
        lv_obj_del(row);
        bsp_display_unlock();
        ESP_LOGE(TAG, "创建左侧容器失败");
        return;
    }
    
    lv_obj_set_width(left_container, LV_PCT(70));
    lv_obj_set_height(left_container, LV_SIZE_CONTENT);
    lv_obj_set_flex_flow(left_container, LV_FLEX_FLOW_ROW_WRAP);
    lv_obj_set_style_border_width(left_container, 0, 0);
    lv_obj_set_style_pad_all(left_container, 0, 0);
    
    // 解析菜品信息
    cJSON *root = cJSON_Parse(dishes);
    if (root) {
        cJSON *items = cJSON_GetObjectItem(root, "items");
        if (items && cJSON_IsArray(items)) {
            // 记录菜品数量，用于调试
            int item_count = cJSON_GetArraySize(items);
            ESP_LOGI(TAG, "菜品数量: %d", item_count);
            
            cJSON *item = NULL;
            cJSON_ArrayForEach(item, items) {
                cJSON *name = cJSON_GetObjectItem(item, "name");
                if (name && cJSON_IsString(name)) {
                    // 记录原始编码的菜品名称
                    ESP_LOGI(TAG, "原始菜品名称: %s", name->valuestring);
                    
                    // 解码Unicode编码的菜品名称
                    ESP_LOGI(TAG, "原始菜品名称编码: %s", name->valuestring);
                    char* decoded_name = decode_unicode_hex(name->valuestring);
                    if (decoded_name) {
                        ESP_LOGI(TAG, "解码后菜品名称: %s (长度: %d)", decoded_name, strlen(decoded_name));
                        // 调试输出：检查每个字符的编码
                        for (int k = 0; k < strlen(decoded_name); k++) {
                            ESP_LOGI(TAG, "字符[%d]: 0x%02X '%c'", k, (unsigned char)decoded_name[k], 
                                    isprint((unsigned char)decoded_name[k]) ? decoded_name[k] : '.');
                        }
                        create_dish_card(left_container, decoded_name);
                        free(decoded_name);
                    } else {
                        ESP_LOGI(TAG, "解码失败，使用原始名称: %s", name->valuestring);
                        create_dish_card(left_container, name->valuestring);
                    }
                }
            }
        } else {
            ESP_LOGW(TAG, "JSON中没有找到items数组或格式不正确");
        }
        cJSON_Delete(root);
    } else {
        // 回退到字符串解析
        char *dishes_copy = strdup(dishes);
        if (dishes_copy) {
            char *token = strtok(dishes_copy, " ");
            while (token) {
                create_dish_card(left_container, token);
                token = strtok(NULL, " ");
            }
            free(dishes_copy);
        }
    }
    
    order->dish_label = left_container;

    // 右侧：已出餐按钮
    lv_obj_t *btn_ready = lv_btn_create(row);
    if (!btn_ready) {
        free(order->dishes);
        free(order->order_id);
        free(order);
        lv_obj_del(left_container);
        lv_obj_del(row);
        bsp_display_unlock();
        ESP_LOGE(TAG, "创建按钮失败");
        return;
    }
    
    lv_obj_set_size(btn_ready, 140, 90);
    lv_obj_align(btn_ready, LV_ALIGN_RIGHT_MID, 0, 0);
    lv_obj_set_style_bg_color(btn_ready, lv_color_hex(0x0CC160), LV_PART_MAIN);
    lv_obj_set_style_radius(btn_ready, 4, LV_PART_MAIN);
    lv_obj_set_style_border_width(btn_ready, 0, LV_PART_MAIN);
    lv_obj_clear_flag(btn_ready, LV_OBJ_FLAG_SCROLLABLE);
    
    // 简化按钮状态效果
    lv_obj_set_style_bg_color(btn_ready, lv_color_hex(0x0AA858), LV_PART_MAIN | LV_STATE_PRESSED);
    
    // 创建按钮标签使用静态文本减少内存分配
    lv_obj_t *btn_label = lv_label_create(btn_ready);
    lv_label_set_text_static(btn_label, "出餐");
    lv_obj_set_style_text_color(btn_label, lv_color_white(), 0);
    lv_obj_set_style_text_font(btn_label, device_font, 0);
    lv_obj_center(btn_label);
    lv_obj_clear_flag(btn_label, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_add_event_cb(btn_ready, btn_ready_cb, LV_EVENT_CLICKED, NULL);

    STAILQ_INSERT_TAIL(&order_list, order, entries);
    bsp_display_unlock();
}

// 创建订单行（动态添加到 UI）
void create_dynamic_order_row(int order_num, const char *dishes) {
    // 默认使用订单号作为ID
    char default_id[32];
    snprintf(default_id, sizeof(default_id), "order_%d", order_num);
    create_dynamic_order_row_with_id(default_id, order_num, dishes);
}

// 根据订单ID删除订单（优化锁定时间）
void remove_order_by_id(const char *order_id) {
    order_info_t *order = find_order_by_id(order_id);
    if (!order) {
        ESP_LOGW(TAG, "订单ID %s 不存在，无法删除", order_id);
        return;
    }
    
    bsp_display_lock(0); // 使用0ms超时，只在需要时锁定

    // 从UI中移除订单行
    if (order->row_widget && lv_obj_is_valid(order->row_widget)) {
        lv_obj_del(order->row_widget);
        order->row_widget = NULL;
    }

    // 从队列中移除并释放内存
    STAILQ_REMOVE(&order_list, order, order_info, entries);
    free(order->order_id);
    free(order->dishes);
    free(order);

    // 如果删除后队列为空，恢复等待标签
    if (STAILQ_EMPTY(&order_list) && orders_container && lv_obj_is_valid(orders_container) && !waiting_label) {
        waiting_label = lv_label_create(orders_container);
        lv_obj_set_style_text_font(waiting_label, device_font, 0);
        lv_label_set_text(waiting_label, "已连接");
        lv_obj_center(waiting_label);
    }

    bsp_display_unlock();
    ESP_LOGI(TAG, "已删除订单: %s", order_id);
}

// 根据订单ID更新订单信息（优化锁定时间）
void update_order_by_id(const char *order_id, int order_num, const char *dishes) {
    order_info_t *order = find_order_by_id(order_id);
    if (!order) {
        ESP_LOGW(TAG, "订单ID %s 不存在，无法更新", order_id);
        return;
    }
    
    bsp_display_lock(0); // 使用0ms超时，只在需要时锁定

    // 更新订单信息
    order->order_num = order_num;
    
    // 安全更新菜品信息
    char *new_dishes = strdup(dishes);
    if (new_dishes) {
        free(order->dishes);
        order->dishes = new_dishes;
    }
    
    // 更新UI显示 - 清除旧的菜品卡片并创建新的
    if (order->dish_label && lv_obj_is_valid(order->dish_label)) {
        // 清除所有子对象（菜品卡片）
        lv_obj_clean(order->dish_label);
        
        // 重新解析菜品信息并创建卡片
        cJSON *root = cJSON_Parse(dishes);
        if (root) {
            cJSON *items = cJSON_GetObjectItem(root, "items");
            if (items && cJSON_IsArray(items)) {
                // 记录菜品数量，用于调试
                int item_count = cJSON_GetArraySize(items);
                ESP_LOGI(TAG, "更新菜品数量: %d", item_count);
                
                cJSON *item = NULL;
                cJSON_ArrayForEach(item, items) {
                    cJSON *name = cJSON_GetObjectItem(item, "name");
                    if (name && cJSON_IsString(name)) {
                        // 记录原始编码的菜品名称
                        ESP_LOGI(TAG, "更新原始菜品名称: %s", name->valuestring);
                        
                        // 使用已有的解码函数
                        ESP_LOGI(TAG, "更新原始菜品名称编码: %s", name->valuestring);
                        char* decoded_name = decode_unicode_hex(name->valuestring);
                        if (decoded_name) {
                            ESP_LOGI(TAG, "更新解码后菜品名称: %s (长度: %d)", decoded_name, strlen(decoded_name));
                            // 调试输出：检查每个字符的编码
                            for (int k = 0; k < strlen(decoded_name); k++) {
                                ESP_LOGI(TAG, "更新字符[%d]: 0x%02X '%c'", k, (unsigned char)decoded_name[k], 
                                        isprint((unsigned char)decoded_name[k]) ? decoded_name[k] : '.');
                            }
                            create_dish_card(order->dish_label, decoded_name);
                            free(decoded_name);
                        } else {
                            ESP_LOGI(TAG, "更新解码失败，使用原始名称: %s", name->valuestring);
                            create_dish_card(order->dish_label, name->valuestring);
                        }
                    }
                }
            } else {
                ESP_LOGW(TAG, "更新JSON中没有找到items数组或格式不正确");
            }
            cJSON_Delete(root);
        } else {
            // 回退到字符串解析
            char *dishes_copy = strdup(dishes);
            if (dishes_copy) {
                char *token = strtok(dishes_copy, " ");
                while (token) {
                    create_dish_card(order->dish_label, token);
                    token = strtok(NULL, " ");
                }
                free(dishes_copy);
            }
        }
    }
    
    bsp_display_unlock();
}